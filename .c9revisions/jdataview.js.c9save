{"ts":1351965726202,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1351965728994,"patch":[[{"diffs":[[1,"//\n// jDataView by Vjeux - Jan 2010\n//\n// A unique way to read a binary file in the browser\n// http://github.com/vjeux/jDataView\n// http://blog.vjeux.com/ <vjeuxx@gmail.com>\n//\n\n(function (global) {\n\nvar compatibility = {\n    ArrayBuffer: typeof ArrayBuffer !== 'undefined',\n\tDataView: typeof DataView !== 'undefined' &&\n\t\t('getFloat64' in DataView.prototype ||\t\t\t\t// Chrome\n\t\t 'getFloat64' in new DataView(new ArrayBuffer(1))), // Node\n\t// NodeJS Buffer in v0.5.5 and newer\n\tNodeBuffer: typeof Buffer !== 'undefined' && 'readInt16LE' in Buffer.prototype\n};\n\nvar dataTypes = {\n\t'Int8': 1,\n\t'Int16': 2,\n\t'Int32': 4,\n\t'Uint8': 1,\n\t'Uint16': 2,\n\t'Uint32': 4,\n\t'Float32': 4,\n\t'Float64': 8\n};\n\nvar nodeNaming = {\n\t'Int8': 'Int8',\n\t'Int16': 'Int16',\n\t'Int32': 'Int32',\n\t'Uint8': 'UInt8',\n\t'Uint16': 'UInt16',\n\t'Uint32': 'UInt32',\n\t'Float32': 'Float',\n\t'Float64': 'Double'\n};\n\nvar jDataView = function (buffer, byteOffset, byteLength, littleEndian) {\n\tif (!(this instanceof jDataView)) {\n\t\tthrow new Error(\"jDataView constructor may not be called as a function\");\n\t}\n\n\tthis.buffer = buffer;\n\n\t// Handle Type Errors\n\tif (!(compatibility.NodeBuffer && buffer instanceof Buffer) &&\n\t\t!(compatibility.ArrayBuffer && buffer instanceof ArrayBuffer) &&\n\t\ttypeof buffer !== 'string') {\n\t\tthrow new TypeError('jDataView buffer has an incompatible type');\n\t}\n\n\t// Check parameters and existing functionnalities\n\tthis._isArrayBuffer = compatibility.ArrayBuffer && buffer instanceof ArrayBuffer;\n\tthis._isDataView = compatibility.DataView && this._isArrayBuffer;\n\tthis._isNodeBuffer = compatibility.NodeBuffer && buffer instanceof Buffer;\n\n\t// Default Values\n\tthis._littleEndian = littleEndian === undefined ? false : littleEndian;\n\n\tvar bufferLength = this._isArrayBuffer ? buffer.byteLength : buffer.length;\n\tif (byteOffset === undefined) {\n\t\tbyteOffset = 0;\n\t}\n\tthis.byteOffset = byteOffset;\n\n\tif (byteLength === undefined) {\n\t\tbyteLength = bufferLength - byteOffset;\n\t}\n\tthis.byteLength = byteLength;\n\n\tif (!this._isDataView) {\n\t\t// Do additional checks to simulate DataView\n\t\tif (typeof byteOffset !== 'number') {\n\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t}\n\t\tif (typeof byteLength !== 'number') {\n\t\t\tthrow new TypeError('jDataView byteLength is not a number');\n\t\t}\n\t\tif (byteOffset < 0) {\n\t\t\tthrow new Error('jDataView byteOffset is negative');\n\t\t}\n\t\tif (byteLength < 0) {\n\t\t\tthrow new Error('jDataView byteLength is negative');\n\t\t}\n\t}\n\n\t// Instanciate\n\tif (this._isDataView) {\n\t\tthis._view = new DataView(buffer, byteOffset, byteLength);\n\t\tthis._start = 0;\n\t}\n\tthis._start = byteOffset;\n\tif (byteOffset + byteLength > bufferLength) {\n\t\tthrow new Error(\"jDataView (byteOffset + byteLength) value is out of bounds\");\n\t}\n\n\tthis._offset = 0;\n\n\t// Create uniform reading methods (wrappers) for the following data types\n\n\tif (this._isDataView) { // DataView: we use the direct method\n\t\tfor (var type in dataTypes) {\n\t\t\tif (!dataTypes.hasOwnProperty(type)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(function(type, view){\n\t\t\t\tvar size = dataTypes[type];\n\t\t\t\tview['get' + type] = function (byteOffset, littleEndian) {\n\t\t\t\t\t// Handle the lack of endianness\n\t\t\t\t\tif (littleEndian === undefined) {\n\t\t\t\t\t\tlittleEndian = view._littleEndian;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\t\tif (byteOffset === undefined) {\n\t\t\t\t\t\tbyteOffset = view._offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move the internal offset forward\n\t\t\t\t\tview._offset = byteOffset + size;\n\n\t\t\t\t\treturn view._view['get' + type](byteOffset, littleEndian);\n\t\t\t\t}\n\t\t\t})(type, this);\n\t\t}\n\t} else if (this._isNodeBuffer && compatibility.NodeBuffer) {\n\t\tfor (var type in dataTypes) {\n\t\t\tif (!dataTypes.hasOwnProperty(type)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar name;\n\t\t\tif (type === 'Int8' || type === 'Uint8') {\n\t\t\t\tname = 'read' + nodeNaming[type];\n\t\t\t} else if (littleEndian) {\n\t\t\t\tname = 'read' + nodeNaming[type] + 'LE';\n\t\t\t} else {\n\t\t\t\tname = 'read' + nodeNaming[type] + 'BE';\n\t\t\t}\n\n\t\t\t(function(type, view, name){\n\t\t\t\tvar size = dataTypes[type];\n\t\t\t\tview['get' + type] = function (byteOffset, littleEndian) {\n\t\t\t\t\t// Handle the lack of endianness\n\t\t\t\t\tif (littleEndian === undefined) {\n\t\t\t\t\t\tlittleEndian = view._littleEndian;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\t\tif (byteOffset === undefined) {\n\t\t\t\t\t\tbyteOffset = view._offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move the internal offset forward\n\t\t\t\t\tview._offset = byteOffset + size;\n\n\t\t\t\t\treturn view.buffer[name](view._start + byteOffset);\n\t\t\t\t}\n\t\t\t})(type, this, name);\n\t\t}\n\t} else {\n\t\tfor (var type in dataTypes) {\n\t\t\tif (!dataTypes.hasOwnProperty(type)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(function(type, view){\n\t\t\t\tvar size = dataTypes[type];\n\t\t\t\tview['get' + type] = function (byteOffset, littleEndian) {\n\t\t\t\t\t// Handle the lack of endianness\n\t\t\t\t\tif (littleEndian === undefined) {\n\t\t\t\t\t\tlittleEndian = view._littleEndian;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\t\tif (byteOffset === undefined) {\n\t\t\t\t\t\tbyteOffset = view._offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move the internal offset forward\n\t\t\t\t\tview._offset = byteOffset + size;\n\n\t\t\t\t\tif (view._isArrayBuffer && (view._start + byteOffset) % size === 0 && (size === 1 || littleEndian)) {\n\t\t\t\t\t\t// ArrayBuffer: we use a typed array of size 1 if the alignment is good\n\t\t\t\t\t\t// ArrayBuffer does not support endianess flag (for size > 1)\n\t\t\t\t\t\treturn new global[type + 'Array'](view.buffer, view._start + byteOffset, 1)[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Error checking:\n\t\t\t\t\t\tif (typeof byteOffset !== 'number') {\n\t\t\t\t\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (byteOffset + size > view.byteLength) {\n\t\t\t\t\t\t\tthrow new Error('jDataView (byteOffset + size) value is out of bounds');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn view['_get' + type](view._start + byteOffset, littleEndian);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})(type, this);\n\t\t}\n\t}\n};\n\nif (compatibility.NodeBuffer) {\n\tjDataView.createBuffer = function () {\n\t\tvar buffer = new Buffer(arguments.length);\n\t\tfor (var i = 0; i < arguments.length; ++i) {\n\t\t\tbuffer[i] = arguments[i];\n\t\t}\n\t\treturn buffer;\n\t}\n} else if (compatibility.ArrayBuffer) {\n\tjDataView.createBuffer = function () {\n\t\tvar buffer = new ArrayBuffer(arguments.length);\n\t\tvar view = new Int8Array(buffer);\n\t\tfor (var i = 0; i < arguments.length; ++i) {\n\t\t\tview[i] = arguments[i];\n\t\t}\n\t\treturn buffer;\n\t}\n} else {\n\tjDataView.createBuffer = function () {\n\t\treturn String.fromCharCode.apply(null, arguments);\n\t}\n}\n\njDataView.prototype = {\n\tcompatibility: compatibility,\n\n\t// Helpers\n\n\tgetString: function (length, byteOffset) {\n\t\tvar value;\n\n\t\t// Handle the lack of byteOffset\n\t\tif (byteOffset === undefined) {\n\t\t\tbyteOffset = this._offset;\n\t\t}\n\n\t\t// Error Checking\n\t\tif (typeof byteOffset !== 'number') {\n\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t}\n\t\tif (length < 0 || byteOffset + length > this.byteLength) {\n\t\t\tthrow new Error('jDataView length or (byteOffset+length) value is out of bounds');\n\t\t}\n\n\t\tif (this._isNodeBuffer) {\n\t\t\tvalue = this.buffer.toString('ascii', this._start + byteOffset, this._start + byteOffset + length);\n\t\t}\n\t\telse {\n\t\t\tvalue = '';\n\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\tvar char = this.getUint8(byteOffset + i);\n\t\t\t\tvalue += String.fromCharCode(char > 127 ? 65533 : char);\n\t\t\t}\n\t\t}\n\n\t\tthis._offset = byteOffset + length;\n\t\treturn value;\n\t},\n\n\tgetChar: function (byteOffset) {\n\t\treturn this.getString(1, byteOffset);\n\t},\n\n\ttell: function () {\n\t\treturn this._offset;\n\t},\n\n\tseek: function (byteOffset) {\n\t\tif (typeof byteOffset !== 'number') {\n\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t}\n\t\tif (byteOffset < 0 || byteOffset > this.byteLength) {\n\t\t\tthrow new Error('jDataView byteOffset value is out of bounds');\n\t\t}\n\n\t\treturn this._offset = byteOffset;\n\t},\n\n\t// Compatibility functions on a String Buffer\n\n\t_endianness: function (byteOffset, pos, max, littleEndian) {\n\t\treturn byteOffset + (littleEndian ? max - pos - 1 : pos);\n\t},\n\n\t_getFloat64: function (byteOffset, littleEndian) {\n\t\tvar b0 = this._getUint8(this._endianness(byteOffset, 0, 8, littleEndian)),\n\t\t\tb1 = this._getUint8(this._endianness(byteOffset, 1, 8, littleEndian)),\n\t\t\tb2 = this._getUint8(this._endianness(byteOffset, 2, 8, littleEndian)),\n\t\t\tb3 = this._getUint8(this._endianness(byteOffset, 3, 8, littleEndian)),\n\t\t\tb4 = this._getUint8(this._endianness(byteOffset, 4, 8, littleEndian)),\n\t\t\tb5 = this._getUint8(this._endianness(byteOffset, 5, 8, littleEndian)),\n\t\t\tb6 = this._getUint8(this._endianness(byteOffset, 6, 8, littleEndian)),\n\t\t\tb7 = this._getUint8(this._endianness(byteOffset, 7, 8, littleEndian)),\n\n\t\t\tsign = 1 - (2 * (b0 >> 7)),\n\t\t\texponent = ((((b0 << 1) & 0xff) << 3) | (b1 >> 4)) - (Math.pow(2, 10) - 1),\n\n\t\t// Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead\n\t\t\tmantissa = ((b1 & 0x0f) * Math.pow(2, 48)) + (b2 * Math.pow(2, 40)) + (b3 * Math.pow(2, 32)) +\n\t\t\t\t\t\t(b4 * Math.pow(2, 24)) + (b5 * Math.pow(2, 16)) + (b6 * Math.pow(2, 8)) + b7;\n\n\t\tif (exponent === 1024) {\n\t\t\tif (mantissa !== 0) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\treturn sign * Infinity;\n\t\t\t}\n\t\t}\n\n\t\tif (exponent === -1023) { // Denormalized\n\t\t\treturn sign * mantissa * Math.pow(2, -1022 - 52);\n\t\t}\n\n\t\treturn sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);\n\t},\n\n\t_getFloat32: function (byteOffset, littleEndian) {\n\t\tvar b0 = this._getUint8(this._endianness(byteOffset, 0, 4, littleEndian)),\n\t\t\tb1 = this._getUint8(this._endianness(byteOffset, 1, 4, littleEndian)),\n\t\t\tb2 = this._getUint8(this._endianness(byteOffset, 2, 4, littleEndian)),\n\t\t\tb3 = this._getUint8(this._endianness(byteOffset, 3, 4, littleEndian)),\n\n\t\t\tsign = 1 - (2 * (b0 >> 7)),\n\t\t\texponent = (((b0 << 1) & 0xff) | (b1 >> 7)) - 127,\n\t\t\tmantissa = ((b1 & 0x7f) << 16) | (b2 << 8) | b3;\n\n\t\tif (exponent === 128) {\n\t\t\tif (mantissa !== 0) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\treturn sign * Infinity;\n\t\t\t}\n\t\t}\n\n\t\tif (exponent === -127) { // Denormalized\n\t\t\treturn sign * mantissa * Math.pow(2, -126 - 23);\n\t\t}\n\n\t\treturn sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);\n\t},\n\n\t_getInt32: function (byteOffset, littleEndian) {\n\t\tvar b = this._getUint32(byteOffset, littleEndian);\n\t\treturn b > Math.pow(2, 31) - 1 ? b - Math.pow(2, 32) : b;\n\t},\n\n\t_getUint32: function (byteOffset, littleEndian) {\n\t\tvar b3 = this._getUint8(this._endianness(byteOffset, 0, 4, littleEndian)),\n\t\t\tb2 = this._getUint8(this._endianness(byteOffset, 1, 4, littleEndian)),\n\t\t\tb1 = this._getUint8(this._endianness(byteOffset, 2, 4, littleEndian)),\n\t\t\tb0 = this._getUint8(this._endianness(byteOffset, 3, 4, littleEndian));\n\n\t\treturn (b3 * Math.pow(2, 24)) + (b2 << 16) + (b1 << 8) + b0;\n\t},\n\n\t_getInt16: function (byteOffset, littleEndian) {\n\t\tvar b = this._getUint16(byteOffset, littleEndian);\n\t\treturn b > Math.pow(2, 15) - 1 ? b - Math.pow(2, 16) : b;\n\t},\n\n\t_getUint16: function (byteOffset, littleEndian) {\n\t\tvar b1 = this._getUint8(this._endianness(byteOffset, 0, 2, littleEndian)),\n\t\t\tb0 = this._getUint8(this._endianness(byteOffset, 1, 2, littleEndian));\n\n\t\treturn (b1 << 8) + b0;\n\t},\n\n\t_getInt8: function (byteOffset) {\n\t\tvar b = this._getUint8(byteOffset);\n\t\treturn b > Math.pow(2, 7) - 1 ? b - Math.pow(2, 8) : b;\n\t},\n\n\t_getUint8: function (byteOffset) {\n\t\tif (this._isArrayBuffer) {\n\t\t\treturn new Uint8Array(this.buffer, byteOffset, 1)[0];\n\t\t}\n\t\telse if (this._isNodeBuffer) {\n\t\t\treturn this.buffer[byteOffset];\n\t\t} else {\n\t\t\treturn this.buffer.charCodeAt(byteOffset) & 0xff;\n\t\t}\n\t}\n};\n\nif (typeof jQuery !== 'undefined' && jQuery.fn.jquery >= \"1.6.2\") {\n\tvar convertResponseBodyToText = function (byteArray) {\n\t\t// http://jsperf.com/vbscript-binary-download/6\n\t\tvar scrambledStr;\n\t\ttry {\n\t\t\tscrambledStr = IEBinaryToArray_ByteStr(byteArray);\n\t\t} catch (e) {\n\t\t\t// http://stackoverflow.com/questions/1919972/how-do-i-access-xhr-responsebody-for-binary-data-from-javascript-in-ie\n\t\t\t// http://miskun.com/javascript/internet-explorer-and-binary-files-data-access/\n\t\t\tvar IEBinaryToArray_ByteStr_Script =\n\t\t\t\t\"Function IEBinaryToArray_ByteStr(Binary)\\r\\n\"+\n\t\t\t\t\"\tIEBinaryToArray_ByteStr = CStr(Binary)\\r\\n\"+\n\t\t\t\t\"End Function\\r\\n\"+\n\t\t\t\t\"Function IEBinaryToArray_ByteStr_Last(Binary)\\r\\n\"+\n\t\t\t\t\"\tDim lastIndex\\r\\n\"+\n\t\t\t\t\"\tlastIndex = LenB(Binary)\\r\\n\"+\n\t\t\t\t\"\tif lastIndex mod 2 Then\\r\\n\"+\n\t\t\t\t\"\t\tIEBinaryToArray_ByteStr_Last = AscB( MidB( Binary, lastIndex, 1 ) )\\r\\n\"+\n\t\t\t\t\"\tElse\\r\\n\"+\n\t\t\t\t\"\t\tIEBinaryToArray_ByteStr_Last = -1\\r\\n\"+\n\t\t\t\t\"\tEnd If\\r\\n\"+\n\t\t\t\t\"End Function\\r\\n\";\n\n\t\t\t// http://msdn.microsoft.com/en-us/library/ms536420(v=vs.85).aspx\n\t\t\t// proprietary IE function\n\t\t\twindow.execScript(IEBinaryToArray_ByteStr_Script, 'vbscript');\n\n\t\t\tscrambledStr = IEBinaryToArray_ByteStr(byteArray);\n\t\t}\n\n\t\tvar lastChr = IEBinaryToArray_ByteStr_Last(byteArray),\n\t\tresult = \"\",\n\t\ti = 0,\n\t\tl = scrambledStr.length % 8,\n\t\tthischar;\n\t\twhile (i < l) {\n\t\t\tthischar = scrambledStr.charCodeAt(i++);\n\t\t\tresult += String.fromCharCode(thischar & 0xff, thischar >> 8);\n\t\t}\n\t\tl = scrambledStr.length\n\t\twhile (i < l) {\n\t\t\tresult += String.fromCharCode(\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8,\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8,\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8,\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8,\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8,\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8,\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8,\n\t\t\t\t(thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8);\n\t\t}\n\t\tif (lastChr > -1) {\n\t\t\tresult += String.fromCharCode(lastChr);\n\t\t}\n\t\treturn result;\n\t};\n\n\tjQuery.ajaxSetup({\n\t\tconverters: {\n\t\t\t'* dataview': function(data) {\n\t\t\t\treturn new jDataView(data);\n\t\t\t}\n\t\t},\n\t\taccepts: {\n\t\t\tdataview: \"text/plain; charset=x-user-defined\"\n\t\t},\n\t\tresponseHandler: {\n\t\t\tdataview: function (responses, options, xhr) {\n\t\t\t\t// Array Buffer Firefox\n\t\t\t\tif ('mozResponseArrayBuffer' in xhr) {\n\t\t\t\t\tresponses.text = xhr.mozResponseArrayBuffer;\n\t\t\t\t}\n\t\t\t\t// Array Buffer Chrome\n\t\t\t\telse if ('responseType' in xhr && xhr.responseType === 'arraybuffer' && xhr.response) {\n\t\t\t\t\tresponses.text = xhr.response;\n\t\t\t\t}\n\t\t\t\t// Internet Explorer (Byte array accessible through VBScript -- convert to text)\n\t\t\t\telse if ('responseBody' in xhr) {\n\t\t\t\t\tresponses.text = convertResponseBodyToText(xhr.responseBody);\n\t\t\t\t}\n\t\t\t\t// Older Browsers\n\t\t\t\telse {\n\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.ajaxPrefilter('dataview', function(options, originalOptions, jqXHR) {\n\t\t// trying to set the responseType on IE 6 causes an error\n\t\tif (jQuery.support.ajaxResponseType) {\n\t\t\tif (!options.hasOwnProperty('xhrFields')) {\n\t\t\t\toptions.xhrFields = {};\n\t\t\t}\n\t\t\toptions.xhrFields.responseType = 'arraybuffer';\n\t\t}\n\t\toptions.mimeType = 'text/plain; charset=x-user-defined';\n\t});\n}\n\nglobal.jDataView = (global.module || {}).exports = jDataView;\nif (typeof module !== 'undefined') {\n\tmodule.exports = jDataView;\n}\n\n})(this);"]],"start1":0,"start2":0,"length1":0,"length2":14980}]],"length":14980,"saved":false}
{"ts":1351965757236,"patch":[[{"diffs":[[0,"r.length"],[1,";"],[0,"\n\t\twhile"]],"start1":12841,"start2":12841,"length1":16,"length2":17}]],"length":14981,"saved":false}
